{
  if (Float.isNaN(d) || Float.isInfinite(d) || d == 0) {
    return d;
  }
  int bits=Float.floatToIntBits(d);
  int sign=bits & Float.SIGN_MASK;
  int factor=((bits & Float.EXPONENT_MASK) >> Float.MANTISSA_BITS) - Float.EXPONENT_BIAS + scaleFactor;
  int subNormalFactor=Integer.numberOfLeadingZeros(bits & ~Float.SIGN_MASK) - Float.EXPONENT_BITS;
  if (subNormalFactor < 0) {
    subNormalFactor=0;
  }
  if (Math.abs(d) < Float.MIN_NORMAL) {
    factor=factor - subNormalFactor;
  }
  if (factor > Float.MAX_EXPONENT) {
    return (d > 0 ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);
  }
  int result;
  if (factor < -Float.EXPONENT_BIAS) {
    int digits=factor + Float.EXPONENT_BIAS + subNormalFactor;
    if (Math.abs(d) < Float.MIN_NORMAL) {
      result=shiftIntBits(bits & Float.MANTISSA_MASK,digits);
    }
 else {
      result=shiftIntBits(bits & Float.MANTISSA_MASK | 0x00800000,digits - 1);
    }
  }
 else {
    if (Math.abs(d) >= Float.MIN_NORMAL) {
      result=((factor + Float.EXPONENT_BIAS) << Float.MANTISSA_BITS) | (bits & Float.MANTISSA_MASK);
    }
 else {
      result=((factor + Float.EXPONENT_BIAS) << Float.MANTISSA_BITS) | ((bits << (subNormalFactor + 1)) & Float.MANTISSA_MASK);
    }
  }
  return Float.intBitsToFloat(result | sign);
}
