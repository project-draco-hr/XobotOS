{
  closeEntry();
  if (entriesEnd) {
    return null;
  }
  Streams.readFully(in,hdrBuf,0,4);
  int hdr=Memory.peekInt(hdrBuf,0,ByteOrder.LITTLE_ENDIAN);
  if (hdr == CENSIG) {
    entriesEnd=true;
    return null;
  }
  if (hdr != LOCSIG) {
    return null;
  }
  Streams.readFully(in,hdrBuf,0,(LOCHDR - LOCVER));
  int version=Memory.peekShort(hdrBuf,0,ByteOrder.LITTLE_ENDIAN) & 0xff;
  if (version > ZIPLocalHeaderVersionNeeded) {
    throw new ZipException("Cannot read local header version " + version);
  }
  short flags=Memory.peekShort(hdrBuf,LOCFLG - LOCVER,ByteOrder.LITTLE_ENDIAN);
  hasDD=((flags & ZipFile.GPBF_DATA_DESCRIPTOR_FLAG) != 0);
  int ceTime=Memory.peekShort(hdrBuf,LOCTIM - LOCVER,ByteOrder.LITTLE_ENDIAN) & 0xffff;
  int ceModDate=Memory.peekShort(hdrBuf,LOCTIM - LOCVER + 2,ByteOrder.LITTLE_ENDIAN) & 0xffff;
  int ceCompressionMethod=Memory.peekShort(hdrBuf,LOCHOW - LOCVER,ByteOrder.LITTLE_ENDIAN) & 0xffff;
  long ceCrc=0, ceCompressedSize=0, ceSize=-1;
  if (!hasDD) {
    ceCrc=((long)Memory.peekInt(hdrBuf,LOCCRC - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
    ceCompressedSize=((long)Memory.peekInt(hdrBuf,LOCSIZ - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
    ceSize=((long)Memory.peekInt(hdrBuf,LOCLEN - LOCVER,ByteOrder.LITTLE_ENDIAN)) & 0xffffffffL;
  }
  int nameLength=Memory.peekShort(hdrBuf,LOCNAM - LOCVER,ByteOrder.LITTLE_ENDIAN) & 0xffff;
  if (nameLength == 0) {
    throw new ZipException("Entry is not named");
  }
  int extraLength=Memory.peekShort(hdrBuf,LOCEXT - LOCVER,ByteOrder.LITTLE_ENDIAN) & 0xffff;
  if (nameLength > nameBuf.length) {
    nameBuf=new byte[nameLength];
    charBuf=new char[nameLength];
  }
  Streams.readFully(in,nameBuf,0,nameLength);
  currentEntry=createZipEntry(ModifiedUtf8.decode(nameBuf,charBuf,0,nameLength));
  currentEntry.time=ceTime;
  currentEntry.modDate=ceModDate;
  currentEntry.setMethod(ceCompressionMethod);
  if (ceSize != -1) {
    currentEntry.setCrc(ceCrc);
    currentEntry.setSize(ceSize);
    currentEntry.setCompressedSize(ceCompressedSize);
  }
  if (extraLength > 0) {
    byte[] extraData=new byte[extraLength];
    Streams.readFully(in,extraData,0,extraLength);
    currentEntry.setExtra(extraData);
  }
  return currentEntry;
}
