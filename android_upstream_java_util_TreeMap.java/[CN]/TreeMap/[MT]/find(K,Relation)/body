{
  if (root == null) {
    if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {
      throw new ClassCastException(key.getClass().getName() + " is not Comparable");
    }
    if (relation == Relation.CREATE) {
      root=new Node<K,V>(null,key);
      size=1;
      modCount++;
      return root;
    }
 else {
      return null;
    }
  }
  @SuppressWarnings("unchecked") Comparable<Object> comparableKey=(comparator == NATURAL_ORDER) ? (Comparable<Object>)key : null;
  Node<K,V> nearest=root;
  while (true) {
    int comparison=(comparableKey != null) ? comparableKey.compareTo(nearest.key) : comparator.compare(key,nearest.key);
    if (comparison == 0) {
switch (relation) {
case LOWER:
        return nearest.prev();
case FLOOR:
case EQUAL:
case CREATE:
case CEILING:
      return nearest;
case HIGHER:
    return nearest.next();
}
}
Node<K,V> child=(comparison < 0) ? nearest.left : nearest.right;
if (child != null) {
nearest=child;
continue;
}
if (comparison < 0) {
switch (relation) {
case LOWER:
case FLOOR:
  return nearest.prev();
case CEILING:
case HIGHER:
return nearest;
case EQUAL:
return null;
case CREATE:
Node<K,V> created=new Node<K,V>(nearest,key);
nearest.left=created;
size++;
modCount++;
rebalance(nearest,true);
return created;
}
}
 else {
switch (relation) {
case LOWER:
case FLOOR:
return nearest;
case CEILING:
case HIGHER:
return nearest.next();
case EQUAL:
return null;
case CREATE:
Node<K,V> created=new Node<K,V>(nearest,key);
nearest.right=created;
size++;
modCount++;
rebalance(nearest,true);
return created;
}
}
}
}
