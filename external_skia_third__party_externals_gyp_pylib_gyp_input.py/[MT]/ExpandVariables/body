def ExpandVariables(input, is_late, variables, build_file):
    if (not is_late):
        variable_re = early_variable_re
        expansion_symbol = '<'
    else:
        variable_re = late_variable_re
        expansion_symbol = '>'
    input_str = str(input)
    if (expansion_symbol in input_str):
        matches = [match for match in variable_re.finditer(input_str)]
    else:
        matches = None
    output = input_str
    if matches:
        matches.reverse()
        for match_group in matches:
            match = match_group.groupdict()
            gyp.DebugOutput(gyp.DEBUG_VARIABLES, ('Matches: %s' % repr(match)))
            run_command = ('!' in match['type'])
            command_string = match['command_string']
            file_list = ('|' in match['type'])
            replace_start = match_group.start('replace')
            replace_end = match_group.end('replace')
            (c_start, c_end) = FindEnclosingBracketGroup(input_str[replace_start:])
            replace_end = (replace_start + c_end)
            replacement = input_str[replace_start:replace_end]
            contents_start = ((replace_start + c_start) + 1)
            contents_end = (replace_end - 1)
            contents = input_str[contents_start:contents_end]
            if file_list:
                processed_variables = copy.deepcopy(variables)
                ProcessListFiltersInDict(contents, processed_variables)
                contents = ExpandVariables(contents, is_late, processed_variables, build_file)
            else:
                contents = ExpandVariables(contents, is_late, variables, build_file)
            contents = contents.strip()
            expand_to_list = (('@' in match['type']) and (input_str == replacement))
            if (run_command or file_list):
                build_file_dir = os.path.dirname(build_file)
                if (build_file_dir == ''):
                    build_file_dir = None
            if file_list:
                if (type(contents) == list):
                    contents_list = contents
                else:
                    contents_list = contents.split(' ')
                replacement = contents_list[0]
                path = replacement
                if (not os.path.isabs(path)):
                    path = os.path.join(build_file_dir, path)
                f = gyp.common.WriteOnDiff(path)
                for i in contents_list[1:]:
                    f.write(('%s\n' % i))
                f.close()
            elif run_command:
                use_shell = True
                if match['is_array']:
                    contents = eval(contents)
                    use_shell = False
                cache_key = str(contents)
                cached_value = cached_command_results.get(cache_key, None)
                if (cached_value is None):
                    gyp.DebugOutput(gyp.DEBUG_VARIABLES, ("Executing command '%s' in directory '%s'" % (contents, build_file_dir)))
                    replacement = ''
                    if (command_string == 'pymod_do_main'):
                        oldwd = os.getcwd()
                        os.chdir(build_file_dir)
                        parsed_contents = shlex.split(contents)
                        py_module = __import__(parsed_contents[0])
                        replacement = str(py_module.DoMain(parsed_contents[1:])).rstrip()
                        os.chdir(oldwd)
                        assert (replacement != None)
                    elif command_string:
                        raise Exception(("Unknown command string '%s' in '%s'." % (command_string, contents)))
                    else:
                        contents = FixupPlatformCommand(contents)
                        p = subprocess.Popen(contents, shell=use_shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, cwd=build_file_dir)
                        (p_stdout, p_stderr) = p.communicate('')
                        if ((p.wait() != 0) or p_stderr):
                            sys.stderr.write(p_stderr)
                            raise Exception(("Call to '%s' returned exit status %d." % (contents, p.returncode)))
                        replacement = p_stdout.rstrip()
                    cached_command_results[cache_key] = replacement
                else:
                    gyp.DebugOutput(gyp.DEBUG_VARIABLES, ("Had cache value for command '%s' in directory '%s'" % (contents, build_file_dir)))
                    replacement = cached_value
            else:
                if (not (contents in variables)):
                    raise KeyError, ((('Undefined variable ' + contents) + ' in ') + build_file)
                replacement = variables[contents]
            if isinstance(replacement, list):
                for item in replacement:
                    if ((not isinstance(item, str)) and (not isinstance(item, int))):
                        raise TypeError, (((('Variable ' + contents) + ' must expand to a string or list of strings; ') + 'list contains a ') + item.__class__.__name__)
                ProcessVariablesAndConditionsInList(replacement, is_late, variables, build_file)
            elif ((not isinstance(replacement, str)) and (not isinstance(replacement, int))):
                raise TypeError, (((('Variable ' + contents) + ' must expand to a string or list of strings; ') + 'found a ') + replacement.__class__.__name__)
            if expand_to_list:
                if isinstance(replacement, list):
                    output = replacement[:]
                else:
                    output = shlex.split(str(replacement))
            else:
                encoded_replacement = ''
                if isinstance(replacement, list):
                    encoded_replacement = gyp.common.EncodePOSIXShellList(replacement)
                else:
                    encoded_replacement = replacement
                output = ((output[:replace_start] + str(encoded_replacement)) + output[replace_end:])
            input_str = output
        gyp.DebugOutput(gyp.DEBUG_VARIABLES, ('Found output %s, recursing.' % repr(output)))
        if isinstance(output, list):
            new_output = []
            for item in output:
                new_output.append(ExpandVariables(item, is_late, variables, build_file))
            output = new_output
        else:
            output = ExpandVariables(output, is_late, variables, build_file)
    if isinstance(output, list):
        for index in xrange(0, len(output)):
            if IsStrCanonicalInt(output[index]):
                output[index] = int(output[index])
    elif IsStrCanonicalInt(output):
        output = int(output)
    gyp.DebugOutput(gyp.DEBUG_VARIABLES, ('Expanding %s to %s' % (repr(input), repr(output))))
    return output
