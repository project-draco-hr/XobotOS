import gyp
import gyp.common
import gyp.SCons as SCons
import os.path
import pprint
import re
WriteList = SCons.WriteList
generator_default_variables = {'EXECUTABLE_PREFIX': '', 'EXECUTABLE_SUFFIX': '', 'STATIC_LIB_PREFIX': '${LIBPREFIX}', 'SHARED_LIB_PREFIX': '${SHLIBPREFIX}', 'STATIC_LIB_SUFFIX': '${LIBSUFFIX}', 'SHARED_LIB_SUFFIX': '${SHLIBSUFFIX}', 'INTERMEDIATE_DIR': '${INTERMEDIATE_DIR}', 'SHARED_INTERMEDIATE_DIR': '${SHARED_INTERMEDIATE_DIR}', 'OS': 'linux', 'PRODUCT_DIR': '$TOP_BUILDDIR', 'SHARED_LIB_DIR': '$LIB_DIR', 'LIB_DIR': '$LIB_DIR', 'RULE_INPUT_ROOT': '${SOURCE.filebase}', 'RULE_INPUT_EXT': '${SOURCE.suffix}', 'RULE_INPUT_NAME': '${SOURCE.file}', 'RULE_INPUT_PATH': '${SOURCE.abspath}', 'CONFIGURATION_NAME': '${CONFIG_NAME}', }
generator_handles_variants = True
generator_wants_absolute_build_file_paths = True
header = '# This file is generated; do not edit.\n'
_alias_template = "\nif GetOption('verbose'):\n  _action = Action([%(action)s])\nelse:\n  _action = Action([%(action)s], %(message)s)\n_outputs = env.Alias(\n  ['_%(target_name)s_action'],\n  %(inputs)s,\n  _action\n)\nenv.AlwaysBuild(_outputs)\n"
_run_as_template = "\nif GetOption('verbose'):\n  _action = Action([%(action)s])\nelse:\n  _action = Action([%(action)s], %(message)s)\n"
_run_as_template_suffix = "\n_run_as_target = env.Alias('run_%(target_name)s', target_files, _action)\nenv.Requires(_run_as_target, [\n    Alias('%(target_name)s'),\n])\nenv.AlwaysBuild(_run_as_target)\n"
_command_template = "\nif GetOption('verbose'):\n  _action = Action([%(action)s])\nelse:\n  _action = Action([%(action)s], %(message)s)\n_outputs = env.Command(\n  %(outputs)s,\n  %(inputs)s,\n  _action\n)\n"
_copy_action_template = "\nimport shutil\nimport SCons.Action\n\ndef _copy_files_or_dirs_or_symlinks(dest, src):\n  SCons.Node.FS.invalidate_node_memos(dest)\n  if SCons.Util.is_List(src) and os.path.isdir(dest):\n    for file in src:\n      shutil.copy2(file, dest)\n    return 0\n  elif os.path.islink(src):\n    linkto = os.readlink(src)\n    os.symlink(linkto, dest)\n    return 0\n  elif os.path.isfile(src):\n    return shutil.copy2(src, dest)\n  else:\n    return shutil.copytree(src, dest, 1)\n\ndef _copy_files_or_dirs_or_symlinks_str(dest, src):\n  return 'Copying %s to %s ...' % (src, dest)\n\nGYPCopy = SCons.Action.ActionFactory(_copy_files_or_dirs_or_symlinks,\n                                     _copy_files_or_dirs_or_symlinks_str,\n                                     convert=str)\n"
_rule_template = "\n%(name)s_additional_inputs = %(inputs)s\n%(name)s_outputs = %(outputs)s\ndef %(name)s_emitter(target, source, env):\n  return (%(name)s_outputs, source + %(name)s_additional_inputs)\nif GetOption('verbose'):\n  %(name)s_action = Action([%(action)s])\nelse:\n  %(name)s_action = Action([%(action)s], %(message)s)\nenv['BUILDERS']['%(name)s'] = Builder(action=%(name)s_action,\n                                      emitter=%(name)s_emitter)\n\n_outputs = []\n_processed_input_files = []\nfor infile in input_files:\n  if (type(infile) == type('')\n      and not os.path.isabs(infile)\n      and not infile[0] == '$'):\n    infile = %(src_dir)r + infile\n  if str(infile).endswith('.%(extension)s'):\n    _generated = env.%(name)s(infile)\n    env.Precious(_generated)\n    _outputs.append(_generated)\n    %(process_outputs_as_sources_line)s\n  else:\n    _processed_input_files.append(infile)\nprerequisites.extend(_outputs)\ninput_files = _processed_input_files\n"
_spawn_hack = '\nimport re\nimport SCons.Platform.posix\nneeds_shell = re.compile(\'["\\\'><!^&]\')\ndef gyp_spawn(sh, escape, cmd, args, env):\n  def strip_scons_quotes(arg):\n    if arg[0] == \'"\' and arg[-1] == \'"\':\n      return arg[1:-1]\n    return arg\n  stripped_args = [strip_scons_quotes(a) for a in args]\n  if needs_shell.search(\' \'.join(stripped_args)):\n    return SCons.Platform.posix.exec_spawnvpe([sh, \'-c\', \' \'.join(args)], env)\n  else:\n    return SCons.Platform.posix.exec_spawnvpe(stripped_args, env)\n'
_wrapper_template = '\n__doc__ = \'\'\'\nWrapper configuration for building this entire "solution,"\nincluding all the specific targets in various *.scons files.\n\'\'\'\n\nimport os\nimport sys\n\nimport SCons.Environment\nimport SCons.Util\n\ndef GetProcessorCount():\n  \'\'\'\n  Detects the number of CPUs on the system. Adapted form:\n  http://codeliberates.blogspot.com/2008/05/detecting-cpuscores-in-python.html\n  \'\'\'\n  # Linux, Unix and Mac OS X:\n  if hasattr(os, \'sysconf\'):\n    if os.sysconf_names.has_key(\'SC_NPROCESSORS_ONLN\'):\n      # Linux and Unix or Mac OS X with python >= 2.5:\n      return os.sysconf(\'SC_NPROCESSORS_ONLN\')\n    else:  # Mac OS X with Python < 2.5:\n      return int(os.popen2("sysctl -n hw.ncpu")[1].read())\n  # Windows:\n  if os.environ.has_key(\'NUMBER_OF_PROCESSORS\'):\n    return max(int(os.environ.get(\'NUMBER_OF_PROCESSORS\', \'1\')), 1)\n  return 1  # Default\n\n# Support PROGRESS= to show progress in different ways.\np = ARGUMENTS.get(\'PROGRESS\')\nif p == \'spinner\':\n  Progress([\'/\\r\', \'|\\r\', \'\\\\\\r\', \'-\\r\'],\n           interval=5,\n           file=open(\'/dev/tty\', \'w\'))\nelif p == \'name\':\n  Progress(\'$TARGET\\r\', overwrite=True, file=open(\'/dev/tty\', \'w\'))\n\n# Set the default -j value based on the number of processors.\nSetOption(\'num_jobs\', GetProcessorCount() + 1)\n\n# Have SCons use its cached dependency information.\nSetOption(\'implicit_cache\', 1)\n\n# Only re-calculate MD5 checksums if a timestamp has changed.\nDecider(\'MD5-timestamp\')\n\n# Since we set the -j value by default, suppress SCons warnings about being\n# unable to support parallel build on versions of Python with no threading.\ndefault_warnings = [\'no-no-parallel-support\']\nSetOption(\'warn\', default_warnings + GetOption(\'warn\'))\n\nAddOption(\'--mode\', nargs=1, dest=\'conf_list\', default=[],\n          action=\'append\', help=\'Configuration to build.\')\n\nAddOption(\'--verbose\', dest=\'verbose\', default=False,\n          action=\'store_true\', help=\'Verbose command-line output.\')\n\n\n#\nsconscript_file_map = %(sconscript_files)s\n\nclass LoadTarget:\n  \'\'\'\n  Class for deciding if a given target sconscript is to be included\n  based on a list of included target names, optionally prefixed with \'-\'\n  to exclude a target name.\n  \'\'\'\n  def __init__(self, load):\n    \'\'\'\n    Initialize a class with a list of names for possible loading.\n\n    Arguments:\n      load:  list of elements in the LOAD= specification\n    \'\'\'\n    self.included = set([c for c in load if not c.startswith(\'-\')])\n    self.excluded = set([c[1:] for c in load if c.startswith(\'-\')])\n\n    if not self.included:\n      self.included = set([\'all\'])\n\n  def __call__(self, target):\n    \'\'\'\n    Returns True if the specified target\'s sconscript file should be\n    loaded, based on the initialized included and excluded lists.\n    \'\'\'\n    return (target in self.included or\n            (\'all\' in self.included and not target in self.excluded))\n\nif \'LOAD\' in ARGUMENTS:\n  load = ARGUMENTS[\'LOAD\'].split(\',\')\nelse:\n  load = []\nload_target = LoadTarget(load)\n\nsconscript_files = []\nfor target, sconscript in sconscript_file_map.iteritems():\n  if load_target(target):\n    sconscript_files.append(sconscript)\n\n\ntarget_alias_list= []\n\nconf_list = GetOption(\'conf_list\')\nif conf_list:\n    # In case the same --mode= value was specified multiple times.\n    conf_list = list(set(conf_list))\nelse:\n    conf_list = [%(default_configuration)r]\n\nsconsbuild_dir = Dir(%(sconsbuild_dir)s)\n\n\ndef FilterOut(self, **kw):\n  kw = SCons.Environment.copy_non_reserved_keywords(kw)\n  for key, val in kw.items():\n    envval = self.get(key, None)\n    if envval is None:\n      # No existing variable in the environment, so nothing to delete.\n      continue\n\n    for vremove in val:\n      # Use while not if, so we can handle duplicates.\n      while vremove in envval:\n        envval.remove(vremove)\n\n    self[key] = envval\n\n    # TODO(sgk): SCons.Environment.Append() has much more logic to deal\n    # with various types of values.  We should handle all those cases in here\n    # too.  (If variable is a dict, etc.)\n\n\nnon_compilable_suffixes = {\n    \'LINUX\' : set([\n        \'.bdic\',\n        \'.css\',\n        \'.dat\',\n        \'.fragment\',\n        \'.gperf\',\n        \'.h\',\n        \'.hh\',\n        \'.hpp\',\n        \'.html\',\n        \'.hxx\',\n        \'.idl\',\n        \'.in\',\n        \'.in0\',\n        \'.in1\',\n        \'.js\',\n        \'.mk\',\n        \'.rc\',\n        \'.sigs\',\n        \'\',\n    ]),\n    \'WINDOWS\' : set([\n        \'.h\',\n        \'.hh\',\n        \'.hpp\',\n        \'.dat\',\n        \'.idl\',\n        \'.in\',\n        \'.in0\',\n        \'.in1\',\n    ]),\n}\n\ndef compilable(env, file):\n  base, ext = os.path.splitext(str(file))\n  if ext in non_compilable_suffixes[env[\'TARGET_PLATFORM\']]:\n    return False\n  return True\n\ndef compilable_files(env, sources):\n  return [x for x in sources if compilable(env, x)]\n\ndef GypProgram(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.Program(target, source, *args, **kw)\n  if env.get(\'INCREMENTAL\'):\n    env.Precious(result)\n  return result\n\ndef GypTestProgram(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.Program(target, source, *args, **kw)\n  if env.get(\'INCREMENTAL\'):\n    env.Precious(*result)\n  return result\n\ndef GypLibrary(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.Library(target, source, *args, **kw)\n  return result\n\ndef GypLoadableModule(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.LoadableModule(target, source, *args, **kw)\n  return result\n\ndef GypStaticLibrary(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.StaticLibrary(target, source, *args, **kw)\n  return result\n\ndef GypSharedLibrary(env, target, source, *args, **kw):\n  source = compilable_files(env, source)\n  result = env.SharedLibrary(target, source, *args, **kw)\n  if env.get(\'INCREMENTAL\'):\n    env.Precious(result)\n  return result\n\ndef add_gyp_methods(env):\n  env.AddMethod(GypProgram)\n  env.AddMethod(GypTestProgram)\n  env.AddMethod(GypLibrary)\n  env.AddMethod(GypLoadableModule)\n  env.AddMethod(GypStaticLibrary)\n  env.AddMethod(GypSharedLibrary)\n\n  env.AddMethod(FilterOut)\n\n  env.AddMethod(compilable)\n\n\nbase_env = Environment(\n    tools = %(scons_tools)s,\n    INTERMEDIATE_DIR=\'$OBJ_DIR/${COMPONENT_NAME}/_${TARGET_NAME}_intermediate\',\n    LIB_DIR=\'$TOP_BUILDDIR/lib\',\n    OBJ_DIR=\'$TOP_BUILDDIR/obj\',\n    SCONSBUILD_DIR=sconsbuild_dir.abspath,\n    SHARED_INTERMEDIATE_DIR=\'$OBJ_DIR/_global_intermediate\',\n    SRC_DIR=Dir(%(src_dir)r),\n    TARGET_PLATFORM=\'LINUX\',\n    TOP_BUILDDIR=\'$SCONSBUILD_DIR/$CONFIG_NAME\',\n    LIBPATH=[\'$LIB_DIR\'],\n)\n\nif not GetOption(\'verbose\'):\n  base_env.SetDefault(\n      ARCOMSTR=\'Creating library $TARGET\',\n      ASCOMSTR=\'Assembling $TARGET\',\n      CCCOMSTR=\'Compiling $TARGET\',\n      CONCATSOURCECOMSTR=\'ConcatSource $TARGET\',\n      CXXCOMSTR=\'Compiling $TARGET\',\n      LDMODULECOMSTR=\'Building loadable module $TARGET\',\n      LINKCOMSTR=\'Linking $TARGET\',\n      MANIFESTCOMSTR=\'Updating manifest for $TARGET\',\n      MIDLCOMSTR=\'Compiling IDL $TARGET\',\n      PCHCOMSTR=\'Precompiling $TARGET\',\n      RANLIBCOMSTR=\'Indexing $TARGET\',\n      RCCOMSTR=\'Compiling resource $TARGET\',\n      SHCCCOMSTR=\'Compiling $TARGET\',\n      SHCXXCOMSTR=\'Compiling $TARGET\',\n      SHLINKCOMSTR=\'Linking $TARGET\',\n      SHMANIFESTCOMSTR=\'Updating manifest for $TARGET\',\n  )\n\nadd_gyp_methods(base_env)\n\nfor conf in conf_list:\n  env = base_env.Clone(CONFIG_NAME=conf)\n  SConsignFile(env.File(\'$TOP_BUILDDIR/.sconsign\').abspath)\n  for sconscript in sconscript_files:\n    target_alias = env.SConscript(sconscript, exports=[\'env\'])\n    if target_alias:\n      target_alias_list.extend(target_alias)\n\nDefault(Alias(\'all\', target_alias_list))\n\nhelp_fmt = \'\'\'\nUsage: hammer [SCONS_OPTIONS] [VARIABLES] [TARGET] ...\n\nLocal command-line build options:\n  --mode=CONFIG             Configuration to build:\n                              --mode=Debug [default]\n                              --mode=Release\n  --verbose                 Print actual executed command lines.\n\nSupported command-line build variables:\n  LOAD=[module,...]         Comma-separated list of components to load in the\n                              dependency graph (\'-\' prefix excludes)\n  PROGRESS=type             Display a progress indicator:\n                              name:  print each evaluated target name\n                              spinner:  print a spinner every 5 targets\n\nThe following TARGET names can also be used as LOAD= module names:\n\n%%s\n\'\'\'\n\nif GetOption(\'help\'):\n  def columnar_text(items, width=78, indent=2, sep=2):\n    result = []\n    colwidth = max(map(len, items)) + sep\n    cols = (width - indent) / colwidth\n    if cols < 1:\n      cols = 1\n    rows = (len(items) + cols - 1) / cols\n    indent = \'%%*s\' %% (indent, \'\')\n    sep = indent\n    for row in xrange(0, rows):\n      result.append(sep)\n      for i in xrange(row, len(items), rows):\n        result.append(\'%%-*s\' %% (colwidth, items[i]))\n      sep = \'\\n\' + indent\n    result.append(\'\\n\')\n    return \'\'.join(result)\n\n  load_list = set(sconscript_file_map.keys())\n  target_aliases = set(map(str, target_alias_list))\n\n  common = load_list and target_aliases\n  load_only = load_list - common\n  target_only = target_aliases - common\n  help_text = [help_fmt %% columnar_text(sorted(list(common)))]\n  if target_only:\n    fmt = "The following are additional TARGET names:\\n\\n%%s\\n"\n    help_text.append(fmt %% columnar_text(sorted(list(target_only))))\n  if load_only:\n    fmt = "The following are additional LOAD= module names:\\n\\n%%s\\n"\n    help_text.append(fmt %% columnar_text(sorted(list(load_only))))\n  Help(\'\'.join(help_text))\n'
